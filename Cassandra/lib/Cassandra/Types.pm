#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Cassandra::ConsistencyLevel;
use constant ZERO => 0;
use constant ONE => 1;
use constant QUORUM => 2;
use constant DCQUORUM => 3;
use constant DCQUORUMSYNC => 4;
use constant ALL => 5;
use constant ANY => 6;
package Cassandra::Column;
use base qw(Class::Accessor);
Cassandra::Column->mk_accessors( qw( name value timestamp ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  $self->{timestamp} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SuperColumn;
use base qw(Class::Accessor);
Cassandra::SuperColumn->mk_accessors( qw( name columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{columns} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Cassandra::Column();
            $xfer += $elem5->read($input);
            push(@{$self->{columns}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SuperColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter6 (@{$self->{columns}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnOrSuperColumn;
use base qw(Class::Accessor);
Cassandra::ColumnOrSuperColumn->mk_accessors( qw( column super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column} = undef;
  $self->{super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnOrSuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::Column();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{super_column} = new Cassandra::SuperColumn();
        $xfer += $self->{super_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnOrSuperColumn');
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 1);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRUCT, 2);
    $xfer += $self->{super_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::NotFoundException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'NotFoundException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NotFoundException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::InvalidRequestException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::InvalidRequestException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidRequestException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidRequestException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::UnavailableException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'UnavailableException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnavailableException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TimedOutException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'TimedOutException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TimedOutException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthenticationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthorizationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthorizationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthorizationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthorizationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnParent;
use base qw(Class::Accessor);
Cassandra::ColumnParent->mk_accessors( qw( column_family super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnParent';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnParent');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnPath;
use base qw(Class::Accessor);
Cassandra::ColumnPath->mk_accessors( qw( column_family super_column column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  $self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnPath';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnPath');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 5);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SliceRange;
use base qw(Class::Accessor);
Cassandra::SliceRange->mk_accessors( qw( start finish reversed count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start} = undef;
  $self->{finish} = undef;
  $self->{reversed} = 0;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
    if (defined $vals->{reversed}) {
      $self->{reversed} = $vals->{reversed};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SliceRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{reversed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SliceRange');
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::STRING, 1);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', TType::STRING, 2);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{reversed}) {
    $xfer += $output->writeFieldBegin('reversed', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{reversed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 4);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SlicePredicate;
use base qw(Class::Accessor);
Cassandra::SlicePredicate->mk_accessors( qw( column_names slice_range ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_names} = undef;
  $self->{slice_range} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_names}) {
      $self->{column_names} = $vals->{column_names};
    }
    if (defined $vals->{slice_range}) {
      $self->{slice_range} = $vals->{slice_range};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SlicePredicate';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{column_names} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $xfer += $input->readString(\$elem12);
            push(@{$self->{column_names}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{slice_range} = new Cassandra::SliceRange();
        $xfer += $self->{slice_range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SlicePredicate');
  if (defined $self->{column_names}) {
    $xfer += $output->writeFieldBegin('column_names', TType::LIST, 1);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{column_names}}));
      {
        foreach my $iter13 (@{$self->{column_names}}) 
        {
          $xfer += $output->writeString($iter13);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{slice_range}) {
    $xfer += $output->writeFieldBegin('slice_range', TType::STRUCT, 2);
    $xfer += $self->{slice_range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeyRange;
use base qw(Class::Accessor);
Cassandra::KeyRange->mk_accessors( qw( start_key end_key start_token end_token count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_key} = undef;
  $self->{end_key} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{end_key}) {
      $self->{end_key} = $vals->{end_key};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeyRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeyRange');
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_key}) {
    $xfer += $output->writeFieldBegin('end_key', TType::STRING, 2);
    $xfer += $output->writeString($self->{end_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 3);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 4);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 5);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeySlice;
use base qw(Class::Accessor);
Cassandra::KeySlice->mk_accessors( qw( key columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeySlice';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{columns} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $elem19 = new Cassandra::ColumnOrSuperColumn();
            $xfer += $elem19->read($input);
            push(@{$self->{columns}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeySlice');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter20 (@{$self->{columns}}) 
        {
          $xfer += ${iter20}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Deletion;
use base qw(Class::Accessor);
Cassandra::Deletion->mk_accessors( qw( timestamp super_column predicate ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{timestamp} = undef;
  $self->{super_column} = undef;
  $self->{predicate} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Deletion';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Deletion');
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 1);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 2);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Mutation;
use base qw(Class::Accessor);
Cassandra::Mutation->mk_accessors( qw( column_or_supercolumn deletion ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_or_supercolumn} = undef;
  $self->{deletion} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_or_supercolumn}) {
      $self->{column_or_supercolumn} = $vals->{column_or_supercolumn};
    }
    if (defined $vals->{deletion}) {
      $self->{deletion} = $vals->{deletion};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Mutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_or_supercolumn} = new Cassandra::ColumnOrSuperColumn();
        $xfer += $self->{column_or_supercolumn}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{deletion} = new Cassandra::Deletion();
        $xfer += $self->{deletion}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Mutation');
  if (defined $self->{column_or_supercolumn}) {
    $xfer += $output->writeFieldBegin('column_or_supercolumn', TType::STRUCT, 1);
    $xfer += $self->{column_or_supercolumn}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deletion}) {
    $xfer += $output->writeFieldBegin('deletion', TType::STRUCT, 2);
    $xfer += $self->{deletion}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TokenRange;
use base qw(Class::Accessor);
Cassandra::TokenRange->mk_accessors( qw( start_token end_token endpoints ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{endpoints} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{endpoints}) {
      $self->{endpoints} = $vals->{endpoints};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size21 = 0;
          $self->{endpoints} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $xfer += $input->readString(\$elem26);
            push(@{$self->{endpoints}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenRange');
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 2);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endpoints}) {
    $xfer += $output->writeFieldBegin('endpoints', TType::LIST, 3);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{endpoints}}));
      {
        foreach my $iter27 (@{$self->{endpoints}}) 
        {
          $xfer += $output->writeString($iter27);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationRequest;
use base qw(Class::Accessor);
Cassandra::AuthenticationRequest->mk_accessors( qw( credentials ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{credentials} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{credentials}) {
      $self->{credentials} = $vals->{credentials};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationRequest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size28 = 0;
          $self->{credentials} = {};
          my $_ktype29 = 0;
          my $_vtype30 = 0;
          $xfer += $input->readMapBegin(\$_ktype29, \$_vtype30, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $key33 = '';
            my $val34 = '';
            $xfer += $input->readString(\$key33);
            $xfer += $input->readString(\$val34);
            $self->{credentials}->{$key33} = $val34;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationRequest');
  if (defined $self->{credentials}) {
    $xfer += $output->writeFieldBegin('credentials', TType::MAP, 1);
    {
      $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{credentials}}));
      {
        while( my ($kiter35,$viter36) = each %{$self->{credentials}}) 
        {
          $xfer += $output->writeString($kiter35);
          $xfer += $output->writeString($viter36);
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
